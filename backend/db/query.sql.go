// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: query.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const groups_CreateOne = `-- name: Groups_CreateOne :one
INSERT INTO
    groups (name, description, user_id)
VALUES ($1, $2, $3) RETURNING id, name, description, user_id, created_at, updated_at
`

type Groups_CreateOneParams struct {
	Name        string
	Description string
	UserID      int64
}

func (q *Queries) Groups_CreateOne(ctx context.Context, arg Groups_CreateOneParams) (Group, error) {
	row := q.db.QueryRow(ctx, groups_CreateOne, arg.Name, arg.Description, arg.UserID)
	var i Group
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.UserID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const groups_DeleteById = `-- name: Groups_DeleteById :one
DELETE FROM groups WHERE id = $1 RETURNING id, name, description, user_id, created_at, updated_at
`

func (q *Queries) Groups_DeleteById(ctx context.Context, id int64) (Group, error) {
	row := q.db.QueryRow(ctx, groups_DeleteById, id)
	var i Group
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.UserID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const groups_GetByPlanId = `-- name: Groups_GetByPlanId :many
SELECT 
    g.id,
    g.name,
    g.description,
    g.user_id,
    g.created_at,
    g.updated_at,
    iga.frequency,
    pi."order" as interval_order
FROM "groups" g
JOIN interval_group_assignments iga on iga.group_id = g.id 
JOIN plan_intervals pi on pi.id = iga.plan_interval_id and pi.plan_id = $1
ORDER BY pi."order" 
LIMIT $2
`

type Groups_GetByPlanIdParams struct {
	PlanID int64
	Limit  int32
}

type Groups_GetByPlanIdRow struct {
	ID            int64
	Name          string
	Description   string
	UserID        int64
	CreatedAt     pgtype.Timestamp
	UpdatedAt     pgtype.Timestamp
	Frequency     int32
	IntervalOrder int32
}

func (q *Queries) Groups_GetByPlanId(ctx context.Context, arg Groups_GetByPlanIdParams) ([]Groups_GetByPlanIdRow, error) {
	rows, err := q.db.Query(ctx, groups_GetByPlanId, arg.PlanID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Groups_GetByPlanIdRow
	for rows.Next() {
		var i Groups_GetByPlanIdRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.UserID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Frequency,
			&i.IntervalOrder,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const groups_GetByUserId = `-- name: Groups_GetByUserId :many
SELECT id, name, description, user_id, created_at, updated_at FROM groups WHERE user_id = $1 ORDER BY created_at LIMIT $2
`

type Groups_GetByUserIdParams struct {
	UserID int64
	Limit  int32
}

func (q *Queries) Groups_GetByUserId(ctx context.Context, arg Groups_GetByUserIdParams) ([]Group, error) {
	rows, err := q.db.Query(ctx, groups_GetByUserId, arg.UserID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Group
	for rows.Next() {
		var i Group
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.UserID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const groups_UpdateOne = `-- name: Groups_UpdateOne :one
UPDATE "groups" SET name = $1, description = $2 WHERE id = $3 RETURNING id, name, description, user_id, created_at, updated_at
`

type Groups_UpdateOneParams struct {
	Name        string
	Description string
	ID          int64
}

func (q *Queries) Groups_UpdateOne(ctx context.Context, arg Groups_UpdateOneParams) (Group, error) {
	row := q.db.QueryRow(ctx, groups_UpdateOne, arg.Name, arg.Description, arg.ID)
	var i Group
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.UserID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const intervalGroupAssignment_CreateOne = `-- name: IntervalGroupAssignment_CreateOne :one
INSERT INTO
    interval_group_assignments (plan_interval_id, group_id, frequency)
VALUES ($1, $2, $3) RETURNING id, plan_interval_id, group_id, frequency
`

type IntervalGroupAssignment_CreateOneParams struct {
	PlanIntervalID int64
	GroupID        int64
	Frequency      int32
}

func (q *Queries) IntervalGroupAssignment_CreateOne(ctx context.Context, arg IntervalGroupAssignment_CreateOneParams) (IntervalGroupAssignment, error) {
	row := q.db.QueryRow(ctx, intervalGroupAssignment_CreateOne, arg.PlanIntervalID, arg.GroupID, arg.Frequency)
	var i IntervalGroupAssignment
	err := row.Scan(
		&i.ID,
		&i.PlanIntervalID,
		&i.GroupID,
		&i.Frequency,
	)
	return i, err
}

const intervalGroupAssignment_DeleteByKey = `-- name: IntervalGroupAssignment_DeleteByKey :one
DELETE FROM interval_group_assignments WHERE plan_interval_id = $1 AND group_id = $2 RETURNING id, plan_interval_id, group_id, frequency
`

type IntervalGroupAssignment_DeleteByKeyParams struct {
	PlanIntervalID int64
	GroupID        int64
}

func (q *Queries) IntervalGroupAssignment_DeleteByKey(ctx context.Context, arg IntervalGroupAssignment_DeleteByKeyParams) (IntervalGroupAssignment, error) {
	row := q.db.QueryRow(ctx, intervalGroupAssignment_DeleteByKey, arg.PlanIntervalID, arg.GroupID)
	var i IntervalGroupAssignment
	err := row.Scan(
		&i.ID,
		&i.PlanIntervalID,
		&i.GroupID,
		&i.Frequency,
	)
	return i, err
}

const planIntervals_CreateOne = `-- name: PlanIntervals_CreateOne :one
INSERT INTO
    plan_intervals (
        plan_id,
        name,
        duration,
        "order"
    )
VALUES ($1, $2, $3, $4)
RETURNING id, plan_id, name, duration, "order", created_at, updated_at
`

type PlanIntervals_CreateOneParams struct {
	PlanID   int64
	Name     pgtype.Text
	Duration pgtype.Interval
	Order    int32
}

func (q *Queries) PlanIntervals_CreateOne(ctx context.Context, arg PlanIntervals_CreateOneParams) (PlanInterval, error) {
	row := q.db.QueryRow(ctx, planIntervals_CreateOne,
		arg.PlanID,
		arg.Name,
		arg.Duration,
		arg.Order,
	)
	var i PlanInterval
	err := row.Scan(
		&i.ID,
		&i.PlanID,
		&i.Name,
		&i.Duration,
		&i.Order,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const planIntervals_DeleteById = `-- name: PlanIntervals_DeleteById :one
DELETE FROM plan_intervals WHERE id = $1 RETURNING id, plan_id, name, duration, "order", created_at, updated_at
`

func (q *Queries) PlanIntervals_DeleteById(ctx context.Context, id int64) (PlanInterval, error) {
	row := q.db.QueryRow(ctx, planIntervals_DeleteById, id)
	var i PlanInterval
	err := row.Scan(
		&i.ID,
		&i.PlanID,
		&i.Name,
		&i.Duration,
		&i.Order,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const planIntervals_GetByPlanId = `-- name: PlanIntervals_GetByPlanId :many
SELECT id, plan_id, name, duration, "order", created_at, updated_at
FROM plan_intervals
WHERE
    plan_id = $1
order by "order"
limit $2
`

type PlanIntervals_GetByPlanIdParams struct {
	PlanID int64
	Limit  int32
}

func (q *Queries) PlanIntervals_GetByPlanId(ctx context.Context, arg PlanIntervals_GetByPlanIdParams) ([]PlanInterval, error) {
	rows, err := q.db.Query(ctx, planIntervals_GetByPlanId, arg.PlanID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PlanInterval
	for rows.Next() {
		var i PlanInterval
		if err := rows.Scan(
			&i.ID,
			&i.PlanID,
			&i.Name,
			&i.Duration,
			&i.Order,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const planIntervals_UpdateOrderByValues = `-- name: PlanIntervals_UpdateOrderByValues :many
UPDATE plan_intervals as p_i 
SET "order" = v.new_order
FROM (VALUES ($1::bigint[], $2::int[])) AS v(ids, new_orders)
WHERE p_i.id = ANY(v.ids)
RETURNING id, plan_id, name, duration, "order", created_at, updated_at
`

type PlanIntervals_UpdateOrderByValuesParams struct {
	IntervalIds []int64
	NewOrders   []int32
}

func (q *Queries) PlanIntervals_UpdateOrderByValues(ctx context.Context, arg PlanIntervals_UpdateOrderByValuesParams) ([]PlanInterval, error) {
	rows, err := q.db.Query(ctx, planIntervals_UpdateOrderByValues, arg.IntervalIds, arg.NewOrders)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PlanInterval
	for rows.Next() {
		var i PlanInterval
		if err := rows.Scan(
			&i.ID,
			&i.PlanID,
			&i.Name,
			&i.Duration,
			&i.Order,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const plans_CreateOne = `-- name: Plans_CreateOne :one
INSERT INTO
    plans (name, description, user_id)
VALUES ($1, $2, $3) RETURNING id, name, description, user_id, created_at, updated_at
`

type Plans_CreateOneParams struct {
	Name        string
	Description string
	UserID      int64
}

func (q *Queries) Plans_CreateOne(ctx context.Context, arg Plans_CreateOneParams) (Plan, error) {
	row := q.db.QueryRow(ctx, plans_CreateOne, arg.Name, arg.Description, arg.UserID)
	var i Plan
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.UserID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const plans_GetByUserId = `-- name: Plans_GetByUserId :many
SELECT id, name, description, user_id, created_at, updated_at FROM plans WHERE user_id = $1 ORDER BY created_at LIMIT $2
`

type Plans_GetByUserIdParams struct {
	UserID int64
	Limit  int32
}

func (q *Queries) Plans_GetByUserId(ctx context.Context, arg Plans_GetByUserIdParams) ([]Plan, error) {
	rows, err := q.db.Query(ctx, plans_GetByUserId, arg.UserID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Plan
	for rows.Next() {
		var i Plan
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.UserID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
