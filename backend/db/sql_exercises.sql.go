// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: sql_exercises.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const exerciseVariations_DeleteOne = `-- name: ExerciseVariations_DeleteOne :exec
DELETE FROM exercise_variations WHERE id = $1
`

func (q *Queries) ExerciseVariations_DeleteOne(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, exerciseVariations_DeleteOne, id)
	return err
}

const exercises_CreateOne = `-- name: Exercises_CreateOne :one
INSERT INTO
    exercises (name, description, user_id)
VALUES ($1, $2, $3) RETURNING id, name, description, user_id, created_at, updated_at
`

type Exercises_CreateOneParams struct {
	Name        string
	Description string
	UserID      pgtype.Int8
}

func (q *Queries) Exercises_CreateOne(ctx context.Context, arg Exercises_CreateOneParams) (Exercise, error) {
	row := q.db.QueryRow(ctx, exercises_CreateOne, arg.Name, arg.Description, arg.UserID)
	var i Exercise
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.UserID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const exercises_DeleteOne = `-- name: Exercises_DeleteOne :exec
DELETE FROM exercises WHERE id = $1
`

func (q *Queries) Exercises_DeleteOne(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, exercises_DeleteOne, id)
	return err
}

const exercises_GetById = `-- name: Exercises_GetById :one
SELECT id, name, description, user_id, created_at, updated_at FROM exercises WHERE id = $1 LIMIT 1
`

func (q *Queries) Exercises_GetById(ctx context.Context, id int64) (Exercise, error) {
	row := q.db.QueryRow(ctx, exercises_GetById, id)
	var i Exercise
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.UserID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const exercises_GetByPlanId = `-- name: Exercises_GetByPlanId :many
SELECT exercises.id, exercises.name, exercises.description, exercises.user_id, exercises.created_at, exercises.updated_at
FROM
    exercises
    JOIN exercise_variations on exercise_variations.exercise_id = exercises.id
    JOIN interval_exercise_prescriptions on exercise_variations.id = interval_exercise_prescriptions.exercise_variation_id
    JOIN plan_intervals on plan_intervals.id = interval_exercise_prescriptions.plan_interval_id
WHERE
    plan_intervals.plan_id = $1
ORDER BY plan_intervals."order"
LIMIT $2
`

type Exercises_GetByPlanIdParams struct {
	PlanID int64
	Limit  int32
}

func (q *Queries) Exercises_GetByPlanId(ctx context.Context, arg Exercises_GetByPlanIdParams) ([]Exercise, error) {
	rows, err := q.db.Query(ctx, exercises_GetByPlanId, arg.PlanID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Exercise
	for rows.Next() {
		var i Exercise
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.UserID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const exercises_GetByUserId = `-- name: Exercises_GetByUserId :many
SELECT id, name, description, user_id, created_at, updated_at
FROM exercises
WHERE
    user_id = $1
ORDER BY created_at
LIMIT $2
`

type Exercises_GetByUserIdParams struct {
	UserID pgtype.Int8
	Limit  int32
}

func (q *Queries) Exercises_GetByUserId(ctx context.Context, arg Exercises_GetByUserIdParams) ([]Exercise, error) {
	rows, err := q.db.Query(ctx, exercises_GetByUserId, arg.UserID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Exercise
	for rows.Next() {
		var i Exercise
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.UserID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const exercises_List = `-- name: Exercises_List :many
SELECT DISTINCT exercises.id, exercises.name, exercises.description, exercises.user_id, exercises.created_at, exercises.updated_at FROM exercises
LEFT JOIN exercise_variations on exercise_variations.exercise_id = exercises.id
LEFT JOIN interval_exercise_prescriptions on exercise_variations.id = interval_exercise_prescriptions.exercise_variation_id
LEFT JOIN plan_intervals on plan_intervals.id = interval_exercise_prescriptions.plan_interval_id
WHERE
    (exercises.id = $1::BIGINT or $1::BIGINT = 0)
    AND (exercises.user_id = $2::BIGINT or $2::BIGINT = 0)
    AND (plan_intervals.plan_id = $3::BIGINT or $3::BIGINT = 0)
    AND (interval_exercise_prescriptions.group_id = $4::BIGINT or $4::BIGINT = 0)
    AND (plan_intervals.id = $5::BIGINT or $5::BIGINT = 0)
ORDER BY exercises.created_at DESC
LIMIT $7::int
OFFSET $6::int
`

type Exercises_ListParams struct {
	ExerciseID int64
	UserID     int64
	PlanID     int64
	GroupID    int64
	IntervalID int64
	Offset     int32
	Limit      int32
}

func (q *Queries) Exercises_List(ctx context.Context, arg Exercises_ListParams) ([]Exercise, error) {
	rows, err := q.db.Query(ctx, exercises_List,
		arg.ExerciseID,
		arg.UserID,
		arg.PlanID,
		arg.GroupID,
		arg.IntervalID,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Exercise
	for rows.Next() {
		var i Exercise
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.UserID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const exercises_UpdateOne = `-- name: Exercises_UpdateOne :one
UPDATE exercises
SET
    name = $1,
    description = $2,
    updated_at = CURRENT_TIMESTAMP
WHERE
    id = $3 RETURNING id, name, description, user_id, created_at, updated_at
`

type Exercises_UpdateOneParams struct {
	Name        string
	Description string
	ID          int64
}

func (q *Queries) Exercises_UpdateOne(ctx context.Context, arg Exercises_UpdateOneParams) (Exercise, error) {
	row := q.db.QueryRow(ctx, exercises_UpdateOne, arg.Name, arg.Description, arg.ID)
	var i Exercise
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.UserID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
